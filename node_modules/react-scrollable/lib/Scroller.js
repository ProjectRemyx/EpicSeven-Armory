'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Scroller = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _shallowEqual = require('./shallowEqual');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var max = Math.max;
var min = Math.min;
var ceil = Math.ceil;
var floor = Math.floor;


var isFunction = function isFunction(fn) {
    return typeof fn === 'function';
};

var addToPrev = function addToPrev(result, height, index) {
    index > 0 ? result.push(result[index - 1] + height) : result.push(height);
    return result;
};

var calcRowOffsets = function calcRowOffsets(rows) {
    return rows.reduce(addToPrev, []);
};

var Scroller = exports.Scroller = function (_Component) {
    _inherits(Scroller, _Component);

    function Scroller() {
        _classCallCheck(this, Scroller);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Scroller).apply(this, arguments));
    }

    _createClass(Scroller, [{
        key: '_cacheRowsHeightsAndOffsets',
        value: function _cacheRowsHeightsAndOffsets(props) {
            var rowHeight = props.rowHeight;
            var size = props.size;

            if (isFunction(rowHeight)) {
                this.rows = Array.from(new Array(size), function (_, index) {
                    return rowHeight(index);
                });
                this.rowOffsets = calcRowOffsets(this.rows);
            }
        }
    }, {
        key: '_calcTopIndex',
        value: function _calcTopIndex() {
            var _props = this.props;
            var size = _props.size;
            var rowHeight = _props.rowHeight;
            var viewPortHeight = _props.viewPortHeight;

            var scrollTop = this._calcScrollTop();
            var offsetTopIndex = void 0;

            if (isFunction(rowHeight)) {
                if (scrollTop >= this.rowOffsets[size - 1]) {
                    scrollTop = this.rowOffsets[size - 1] - viewPortHeight;
                }
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.rowOffsets.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _slicedToArray(_step.value, 2);

                        var index = _step$value[0];
                        var offset = _step$value[1];

                        if (scrollTop < offset) {
                            offsetTopIndex = index;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return offsetTopIndex;
            }

            return min(floor(scrollTop / rowHeight), size);
        }
    }, {
        key: '_calcScrollTop',
        value: function _calcScrollTop() {
            var _props2 = this.props;
            var isBodyScroll = _props2.isBodyScroll;
            var tableStartOffset = _props2.tableStartOffset;
            var scrollTop = _props2.scrollTop;

            return isBodyScroll ? max(scrollTop - tableStartOffset, 0) : scrollTop;
            // return scrollTop;
        }
    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            this._cacheRowsHeightsAndOffsets(this.props);
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return !(0, _shallowEqual.shallowEqual)(this.props, nextProps);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            this._cacheRowsHeightsAndOffsets(nextProps);
        }
    }, {
        key: 'render',
        value: function render() {
            var containerStyle = {
                overflow: 'auto',
                WebkitBackfaceVisibility: 'hidden',
                backfaceVisibility: 'hidden',
                WebkitTransform: 'translateZ(0)',
                transform: 'translateZ(0)',
                WebkitOverflowScrolling: 'touch'
            };

            var _props3 = this.props;
            var className = _props3.className;
            var _props3$style = _props3.style;
            var style = _props3$style === undefined ? {} : _props3$style;

            var finalStyle = _extends({}, containerStyle, style);
            var offsetTopIndex = this._calcTopIndex();

            var from = this._calcFromIndex(offsetTopIndex);
            var to = this._calcToIndex(offsetTopIndex);
            var lastVisibleIndex = this._calcLastVisibleIndex(offsetTopIndex);

            var visibleRowsRange = [offsetTopIndex, lastVisibleIndex];

            return _react2.default.createElement(
                'div',
                { className: className, style: finalStyle },
                _react2.default.createElement('div', { style: { height: this._topPlaceholderHeight(from) }, className: 'Scroller__TopPlaceholder' }),
                this._renderBody(from, to, visibleRowsRange),
                _react2.default.createElement('div', { style: { height: this._bottomPlaceholderHeight(this.props.size, to) }, className: 'Scroller__BottomPlaceholder' })
            );
        }
    }, {
        key: '_renderBody',
        value: function _renderBody(from, to, visibleRowsRange) {
            return _react.Children.map(this.props.children, function (child) {
                return (0, _react.cloneElement)(child, { from: from, to: to, visibleRowsRange: visibleRowsRange }, child.props.children);
            });
        }
    }, {
        key: '_calcFromIndex',
        value: function _calcFromIndex(from) {
            var _props4 = this.props;
            var buffer = _props4.buffer;
            var viewPortHeight = _props4.viewPortHeight;
            var rowHeight = _props4.rowHeight;

            var scrollTop = this._calcScrollTop();
            var diff = viewPortHeight * buffer;

            if (isFunction(rowHeight)) {
                while (from > 0 && diff > 0) {
                    diff -= this.rows[--from];
                }

                return from;
            }

            return max(floor((scrollTop - diff) / rowHeight), 0);
        }
    }, {
        key: '_calcToIndex',
        value: function _calcToIndex(to) {
            var _props5 = this.props;
            var size = _props5.size;
            var buffer = _props5.buffer;
            var viewPortHeight = _props5.viewPortHeight;
            var rowHeight = _props5.rowHeight;

            var scrollTop = this._calcScrollTop();
            var diff = viewPortHeight + viewPortHeight * buffer;

            if (isFunction(rowHeight)) {
                while (to < size && diff > 0) {
                    diff -= this.rows[to++];
                }
                return to;
            }

            return min(ceil((scrollTop + diff) / rowHeight), size);
        }
    }, {
        key: '_calcLastVisibleIndex',
        value: function _calcLastVisibleIndex(topIndex) {
            var _props6 = this.props;
            var size = _props6.size;
            var viewPortHeight = _props6.viewPortHeight;
            var rowHeight = _props6.rowHeight;

            var scrollTop = this._calcScrollTop();
            var diff = viewPortHeight;

            if (isFunction(rowHeight)) {
                while (topIndex < size && diff > 0) {
                    diff -= this.rows[topIndex++];
                }
                return topIndex;
            }

            return min(ceil((scrollTop + diff) / rowHeight), size);
        }
    }, {
        key: '_getRowOffset',
        value: function _getRowOffset(index) {
            var rowHeight = this.props.rowHeight;


            if (isFunction(rowHeight)) {
                return this.rowOffsets[index];
            }

            return rowHeight * (index + 1);
        }
    }, {
        key: '_topPlaceholderHeight',
        value: function _topPlaceholderHeight(from) {
            return from == 0 ? 0 : this._getRowOffset(from - 1);
        }
    }, {
        key: '_bottomPlaceholderHeight',
        value: function _bottomPlaceholderHeight(size, to) {
            return this._getRowOffset(size - 1) - this._getRowOffset(to - 1);
        }
    }, {
        key: 'getRowOffsetTop',
        value: function getRowOffsetTop(index) {
            var offset = index === 0 ? 0 : this._getRowOffset(index - 1);

            if (this.props.isBodyScroll) {
                return offset + this.props.tableStartOffset;
            }

            return offset;
        }
    }]);

    return Scroller;
}(_react.Component);

Scroller.propTypes = {
    rowHeight: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.func]).isRequired,
    size: _react.PropTypes.number.isRequired,
    scrollTop: _react.PropTypes.number.isRequired,
    viewPortHeight: _react.PropTypes.number.isRequired,
    isBodyScroll: _react.PropTypes.bool.isRequired,
    tableStartOffset: _react.PropTypes.number,
    buffer: _react.PropTypes.number
};
Scroller.defaultProps = {
    tableStartOffset: 0,
    buffer: 1,
    isBodyScroll: true
};